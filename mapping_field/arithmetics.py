
from mapping_field.associative import AssociativeListFunction, _sorted_commutative_simplifier
from mapping_field.log_utils.tree_loggers import TreeLogger
from mapping_field.mapping_field import (
    CompositeElement, CompositeElementFromFunction, MapElement,
    MapElementConstant, OutputProperties, SimplifierOutput, Var, class_simplifier,
)
from mapping_field.property_engines import is_integral
from mapping_field.utils.processors import ProcessFailureReason

simplify_logger = TreeLogger(__name__)

"""
Implement arithmetics for the MapElement class.
This is done in a separate file for clarity. To avoid cyclic imports, I override the operator methods here.

When simplifying map with arithmetics I use the following rules:

1. Addition, subtraction, negation: 
    a. Two negations cancel each other:
                -(-a) => a
    b. Negation of subtraction always converge to single subtraction: 
                -(a-b) => b-a
    c. Sum of negation become negation of sum:
                (-a) + (-b) => -(a+b)
                
2. Multiplication, division, negation:
    Any composition of these operators, with be transformed to 
                (+-1) * (a_1 * ... * a_n) / (b_1 * ... * b_m)
    where the a_i, b_j are not multiplication, division or negation.


"""

# --------------------- MapElements for arithmetic operator ---------------------


# <editor-fold desc=" ------------------- Negation ------------------- ">


class _Negative(CompositeElementFromFunction):

    def __init__(self, operand: MapElement | None = None):
        operands = [operand] if operand is not None else None
        super().__init__(operands=operands, name="Neg", function=lambda a: -a)

    @property
    def operand(self) -> MapElement:
        return self.operands[0]

    @operand.setter
    def operand(self, value: MapElement):
        self.operands[0] = value

    def to_string(self, vars_to_str: dict[Var, str]):
        return f"(-{self.operand.to_string(vars_to_str)})"

    def __eq__(self, other: MapElement):
        return isinstance(other, _Negative) and self.operand == other.operand

    __hash__ = MapElement.__hash__

    def _simplify_with_var_values(self) -> MapElement | None:

        operand = self.operand
        if isinstance(operand, _Negative):
            return operand.operand

        return super()._simplify_with_var_values()

    @class_simplifier
    @staticmethod
    def _to_negation_simplifier(neg_func: MapElement) -> MapElement | None:
        assert isinstance(neg_func, _Negative)
        return neg_func.operand.neg()

Neg = _Negative()
MapElement.negation = Neg

# </editor-fold>


# <editor-fold desc=" ------------------- Addition ------------------- ">

class _Add(CompositeElement):
    """
    Only used for simplification purposes, and only generated by AssociativeAddition. Once the simplification
    is done, it is transformed back to an AssociativeAddition object.
    """
    def __init__(self, operands: list[MapElement], output_properties: OutputProperties | None = None):
        assert len(operands) == 2
        super().__init__(operands=operands, name="_Add", output_properties = output_properties)

    @class_simplifier
    @staticmethod
    def _additive_negation_simplifier(add_func: MapElement) -> SimplifierOutput:
        """
                elem +    0     =>  elem
                elem + (-elem)  =>  0
        """
        # Can also implement via _Negative.add(...)
        assert isinstance(add_func, _Add)
        operands = add_func.operands

        if operands[0].evaluate() == 0:
            return operands[1]
        if operands[1].evaluate() == 0:
            return operands[0]

        sign0, map0 = as_neg(operands[0])
        sign1, map1 = as_neg(operands[1])
        if sign0 != sign1:
            if map0 == map1:
                return MapElementConstant.zero

        return ProcessFailureReason('Elements did not cancel each other', trivial = True)

    @class_simplifier
    @staticmethod
    def _numbers_add_simplifier(add_func: MapElement) -> SimplifierOutput:
        """
                2 + 3  =>  5
        """
        assert isinstance(add_func, _Add)
        values = [op.evaluate() for op in add_func.operands]
        if all(value is not None for value in values):
            return MapElementConstant(sum(values, 0))
        return ProcessFailureReason('Not all operands are constant', trivial = True)

    @class_simplifier
    @staticmethod
    def _to_add_simplifier(add_func: MapElement) -> SimplifierOutput:
        """
                x + y   =>  x.add(y)
        """
        assert isinstance(add_func, _Add)
        return (add_func.operands[0].add(add_func.operands[1]) or
                add_func.operands[1].add(add_func.operands[0]))


class MultiAdd(AssociativeListFunction, binary_class=_Add):

    trivial_element = MapElementConstant.zero
    op_symbol = "+"

    def to_string(self, vars_to_str: dict[Var, str]):
        op0 = self.operands[0]
        s = f'-{op0.operand}' if isinstance(op0, _Negative) else str(op0)
        for operand in self.operands[1:]:
            s += f' - {operand.operand}' if isinstance(operand, _Negative) else f' + {operand}'
        return f"{self.__class__.left_bracket}{s}{self.__class__.right_bracket}"

    def neg(self) -> MapElement | None:
        """
                - (x-y) => -x+y
            Only works if this doesn't increase the total number of minus signs.
        """
        neg_counter = sum([isinstance(operand, _Negative) for operand in self.operands],0)
        if len(self.operands)-1 <= 2*neg_counter:
            return MultiAdd([-operand for operand in self.operands])
        return None

    def extract_scalar(self) -> tuple[MapElementConstant, 'MultiAdd'] | None:
        summands = []
        scalar = 0
        for summand in self.operands:
            value = summand.evaluate()
            if value is None:
                summands.append(summand)
            else:
                scalar += value
        if len(summands) < len(self.operands):
            return MapElementConstant(scalar), MultiAdd(summands)
        else:
            return None

    @class_simplifier
    @staticmethod
    def _neg_extractor_simplifier(multi_add: MapElement) -> SimplifierOutput:
        """
                (x - y - z - w) => -(-x+y+z+w)
            Only works if this strictly reduces the total number of minus signs.
        """
        assert isinstance(multi_add, MultiAdd)
        neg_counter = sum([isinstance(operand, _Negative) for operand in multi_add.operands],0)
        if len(multi_add.operands)+1 < 2*neg_counter:
            return Neg(MultiAdd([-operand for operand in multi_add.operands]))
        return ProcessFailureReason('Not enough negations to extract', trivial = True)

    @class_simplifier
    @staticmethod
    def _unpack_minus_summand(multi_add: MapElement) -> SimplifierOutput:
        """
                x - (y+z)   =>      x + (-y) + (-z)
            Unlike just negation of MultiAdd, where we simplify only when the number of minus signs decrease,
            as a partial sum we always open the brackets.
        """
        assert isinstance(multi_add, MultiAdd)
        non_minus_summands = []
        minus_summands = []
        for summand in multi_add.operands:
            if isinstance(summand, _Negative) and isinstance(summand.operand, MultiAdd):
                for sub_summand in summand.operand.operands:
                    minus_summands.append(-sub_summand)
            else:
                non_minus_summands.append(summand)
        if len(minus_summands) > 0:
            return MultiAdd(non_minus_summands + minus_summands)
        return ProcessFailureReason('No minus signs', trivial = True)

Add = MultiAdd([Var(f"X_Add_1"), Var(f"X_Add_2")])
MapElement.addition = Add

MultiAdd.register_class_simplifier(_sorted_commutative_simplifier)

def Sub(x, y):
    return Add(x, -y)
MapElement.subtraction = Sub

# </editor-fold>



# </editor-fold>


# <editor-fold desc=" ------------------- Multiplication ------------------- ">


class _Mult(CompositeElementFromFunction):

    def __init__(self, operands: list[MapElement] | None = None) -> None:
        assert operands is None or len(operands) == 2
        super().__init__(operands=operands, name="Mult", function=lambda a, b: a * b)

    def __eq__(self, other) -> bool:
        if isinstance(other, _Mult):
            return self.operands == other.operands or self.operands == list(reversed(other.operands))
        return False

    __hash__ = MapElement.__hash__

    def _simplify_with_var_values(self) -> MapElement | None:
        operands = self.operands

        # Multiplication by 0 and 1
        if operands[0].evaluate() == 0:
            return MapElementConstant.zero
        if operands[0].evaluate() == 1:
            return operands[1]

        if operands[1].evaluate() == 0:
            return MapElementConstant.zero
        if operands[1].evaluate() == 1:
            return operands[0]

        if operands[0].evaluate() == -1:
            return Neg(operands[1])
        if operands[1].evaluate() == -1:
            return Neg(operands[0])

        sign0, numerator0, denominator0 = _as_rational(operands[0])
        sign1, numerator1, denominator1 = _as_rational(operands[1])
        if operands[0] is numerator0 and operands[1] is numerator1:
            return super()._simplify_with_var_values()

        numerator = numerator0 * numerator1
        denominator = denominator0 * denominator1
        abs_value = numerator / denominator
        return abs_value.simplify() if sign0 * sign1 == 1 else (-abs_value).simplify()

    def to_string(self, vars_to_str: dict[Var, str]):
        return f"({self.operands[0]}*{self.operands[1]})"

    @class_simplifier
    @staticmethod
    def _to_mult_simplifier(mul_func: MapElement) -> MapElement | None:
        assert isinstance(mul_func, _Mult)
        return (mul_func.operands[0].mul(mul_func.operands[1]) or
                mul_func.operands[1].mul(mul_func.operands[0]))

Mult = _Mult()
MapElement.multiplication = Mult

# </editor-fold>


# <editor-fold desc=" ------------------- Division ------------------- ">


class _Div(CompositeElementFromFunction):

    def __init__(self, operands: list[MapElement] | None = None) -> None:
        assert operands is None or len(operands) == 2
        super().__init__(operands=operands, name="Div", function=lambda a, b: a / b)

    def __eq__(self, other) -> bool:
        return isinstance(other, _Div) and self.operands == other.operands

    __hash__ = MapElement.__hash__

    def _simplify_with_var_values(self) -> MapElement | None:
        operands = self.operands

        if operands[1] == 0:
            raise Exception("Cannot divide by zero")
        if operands[1] == 1:
            return operands[0]

        if operands[0] == 0:
            return operands[0]

        sign0, numerator0, denominator0 = _as_rational(operands[0])
        sign1, numerator1, denominator1 = _as_rational(operands[1])
        if operands[0] is numerator0 and operands[1] is numerator1:
            return super()._simplify_with_var_values()

        abs_value = (numerator0 * denominator1) / (denominator0 * numerator1)
        return abs_value if sign0 * sign1 == 1 else -abs_value

    def to_string(self, vars_to_str: dict[Var, str]):
        return f"( {self.operands[0]}/{self.operands[1]} )"

    @class_simplifier
    @staticmethod
    def _to_div_simplifier(div_func: MapElement) -> MapElement | None:
        assert isinstance(div_func, _Div)
        return (div_func.operands[0].div(div_func.operands[1]) or
                div_func.operands[1].rdiv(div_func.operands[0]))

Div = _Div()
MapElement.division = Div

# </editor-fold>

is_integral.add_property_preserving_class([_Add, MultiAdd, _Mult, _Negative])


# Arithmetic decompositions

def as_neg(map_elem: MapElement) -> tuple[int, MapElement]:
    if isinstance(map_elem, _Negative):
        return -1, map_elem.operand

    return 1, map_elem

def _as_scalar_mult(map_elem: MapElement) -> tuple[int, MapElement]:
    value = map_elem.evaluate()
    if value is not None:
        return value, MapElementConstant.one

    if isinstance(map_elem, _Negative):
        c, map_elem = _as_scalar_mult(map_elem.operand)
        return -c, map_elem

    if not isinstance(map_elem, _Mult):
        return 1, map_elem

    a, b = map_elem.operands
    a_value = a.evaluate()
    b_value = b.evaluate()
    if a_value is not None:
        if b_value is not None:
            return a_value * b_value, MapElementConstant.one
        return a_value, b
    if b_value is not None:
        return b_value, a

    return 1, map_elem


# TODO: consider creating a LinearCombination class?
#       also, make this function recursive.
def _as_combination(map_elem: MapElement) -> tuple[int, MapElement, int, MapElement]:
    if isinstance(map_elem, MapElementConstant):
        return map_elem.evaluate(), MapElementConstant.one, 0, MapElementConstant.zero

    if isinstance(map_elem, _Negative):
        c0, elem0, c1, elem1 = _as_combination(map_elem.operand)
        return -c0, elem0, -c1, elem1

    if isinstance(map_elem, MultiAdd):
        num_operands = len(map_elem.operands)
        if num_operands == 0:
            return 0, MapElementConstant.one, 0, MapElementConstant.zero
        if num_operands == 1:
            return _as_combination(map_elem.operands[0])
        if num_operands == 2:
            c0, elem0 = _as_scalar_mult(map_elem.operands[0])
            c1, elem1 = _as_scalar_mult(map_elem.operands[1])
            if c0 == 0 or elem0 is MapElementConstant.one:
                return c1, elem1, c0, elem0
            return c0, elem0, c1, elem1
        result = map_elem.extract_scalar()
        if result is not None:
            scalar, rest = result
            c0, elem0 = _as_scalar_mult(rest)
            return c0, elem0, scalar.evaluate(), MapElementConstant.one

    if isinstance(map_elem, _Add):
        c0, elem0 = _as_scalar_mult(map_elem.operands[0])
        c1, elem1 = _as_scalar_mult(map_elem.operands[1])
        if c0 == 0 or elem0 is MapElementConstant.one:
            return c1, elem1, c0, elem0
        return c0, elem0, c1, elem1

    c, elem = _as_scalar_mult(map_elem)
    return c, elem, 0, MapElementConstant.zero


def _as_rational(map_elem: MapElement) -> (int, MapElement, MapElement):
    """
    :return: sign, numerator, denominator
    """
    sign = 1
    if isinstance(map_elem, _Negative):
        sign = -1
        map_elem = map_elem.operand

    if isinstance(map_elem, _Div):
        return sign, map_elem.operands[0], map_elem.operands[1]

    return sign, map_elem, MapElementConstant.one


class BinaryCombination(MapElement):
    # TODO: Right now this is ONLY used for the simplification process inside Linear. Don't generate it for other
    #       reasons.
    #       Later, I should just make a LinearCombination element for expressions of the form sum c_i f_i

    def __init__(self, c1: int, elem1: MapElement, c2: int, elem2: MapElement):
        super().__init__(list(set(elem1.vars + elem2.vars)))
        self.c1 = c1
        self.elem1 = elem1
        self.c2 = c2
        self.elem2 = elem2

    def to_string(self, vars_to_str: dict[Var, str]):
        return f"Comb[{self.c1}*{self.elem1.to_string(vars_to_str)}+{self.c2}*{self.elem2.to_string(vars_to_str)}]"

    def _simplify_with_var_values(self) -> MapElement | None:
        if self.c1 == 0:
            return self.c2 * self.elem2
        if self.c2 == 0:
            return self.c1 * self.elem1

        elem1 = self.elem1._simplify()
        elem2 = self.elem2._simplify()
        if elem1 is not None or elem2 is not None:
            elem1 = elem1 or self.elem1
            elem2 = elem2 or self.elem2
            return BinaryCombination(self.c1, elem1, self.c2, elem2)
        return None


# TODO: add tests
def _binary_combination_simplifier(function: MapElement) -> SimplifierOutput:
    """
        convert to (c1 * elem1 + c2 * elem2) for simplification.
    """
    assert isinstance(function, _Add)
    c1, elem1, c2, elem2 = _as_combination(function)
    if c2 == 0:
        return None
    result = BinaryCombination(c1, elem1, c2, elem2)._simplify()
    if result is None or isinstance(result, BinaryCombination):
        return None
    return result

# TODO: should class simplifiers be inherited?
_Add.register_class_simplifier(_binary_combination_simplifier)

_Mult.register_class_simplifier(_sorted_commutative_simplifier)
