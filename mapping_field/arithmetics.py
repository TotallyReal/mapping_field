from typing import Dict, List, Optional, Tuple, Union

from mapping_field.associative import AssociativeListFunction, _sorted_commutative_simplifier
from mapping_field.log_utils.tree_loggers import TreeLogger
from mapping_field.mapping_field import (
    CompositeElement, CompositeElementFromFunction, MapElement, MapElementConstant, Var,
    class_simplifier,
)
from mapping_field.utils.processors import ProcessFailureReason

simplify_logger = TreeLogger(__name__)

"""
Implement arithmetics for the MapElement class.
This is done in a separate file for clarity. To avoid cyclic imports, I override the operator methods here.

When simplifying map with arithmetics I use the following rules:

1. Addition, subtraction, negation: 
    a. Two negations cancel each other:
                -(-a) => a
    b. Negation of subtraction always converge to single subtraction: 
                -(a-b) => b-a
    c. Sum of negation become negation of sum:
                (-a) + (-b) => -(a+b)
                
2. Multiplication, division, negation:
    Any composition of these operators, with be transformed to 
                (+-1) * (a_1 * ... * a_n) / (b_1 * ... * b_m)
    where the a_i, b_j are not multiplication, division or negation.


"""

# --------------------- MapElements for arithmetic operator ---------------------


# <editor-fold desc=" ------------------- Negation ------------------- ">


class _Negative(CompositeElementFromFunction):

    def __init__(self, operand: Optional[MapElement] = None):
        operands = [operand] if operand is not None else None
        super().__init__(operands=operands, name="Neg", function=lambda a: -a)

    @property
    def operand(self) -> MapElement:
        return self.operands[0]

    @operand.setter
    def operand(self, value: MapElement):
        self.operands[0] = value

    def to_string(self, vars_to_str: Dict[Var, str]):
        return f"(-{self.operand.to_string(vars_to_str)})"

    def _simplify_with_var_values2(self) -> Optional[MapElement]:

        operand = self.operand
        if isinstance(operand, _Negative):
            return operand.operand
        if isinstance(operand, _Sub):
            sub_operands = operand.operands
            return Sub(sub_operands[1], sub_operands[0])

        return super()._simplify_with_var_values2()

    @class_simplifier
    @staticmethod
    def _to_negation_simplifier(neg_func: MapElement) -> Optional[MapElement]:
        assert isinstance(neg_func, _Negative)
        return neg_func.operand.neg()

Neg = _Negative()
MapElement.negation = Neg

# </editor-fold>


# <editor-fold desc=" ------------------- Addition ------------------- ">

class _Add(CompositeElement):
    """
    Only used for simplification purposes, and only generated by AssociativeAddition. Once the simplification
    is done, it is transformed back to an AssociativeAddition object.
    """
    def __init__(self, operands: List[MapElement]):
        assert len(operands) == 2
        super().__init__(operands=operands, name="_Add")

    @class_simplifier
    @staticmethod
    def _additive_negation_simplifier(add_func: MapElement) -> Optional[Union[ProcessFailureReason, MapElement]]:
        """
                elem +    0     =>  elem
                elem + (-elem)  =>  0
        """
        # Can also implement via _Negative.add(...)
        assert isinstance(add_func, _Add)
        operands = add_func.operands

        if operands[0].evaluate() == 0:
            return operands[1]
        if operands[1].evaluate() == 0:
            return operands[0]

        sign0, map0 = as_neg(operands[0])
        sign1, map1 = as_neg(operands[1])
        if sign0 != sign1:
            if map0 == map1:
                return MapElementConstant.zero

        return ProcessFailureReason('Elements did not cancel each other', trivial = True)

    @class_simplifier
    @staticmethod
    def _numbers_add_simplifier(add_func: MapElement) -> Optional[Union[ProcessFailureReason, MapElement]]:
        """
                2 + 3  =>  5
        """
        assert isinstance(add_func, _Add)
        values = [op.evaluate() for op in add_func.operands]
        if all(value is not None for value in values):
            return MapElementConstant(sum(values, 0))
        return ProcessFailureReason('Not all operands are constant', trivial = True)

    @class_simplifier
    @staticmethod
    def _to_add_simplifier(add_func: MapElement) -> Optional[Union[ProcessFailureReason, MapElement]]:
        """
                x + y   =>  x.add(y)
        """
        assert isinstance(add_func, _Add)
        return (add_func.operands[0].add(add_func.operands[1]) or
                add_func.operands[1].add(add_func.operands[0]))


class MultiAdd(AssociativeListFunction, binary_class=_Add):

    trivial_element = MapElementConstant.zero
    op_symbol = "+"

    @class_simplifier
    @staticmethod
    def _to_sub_simplifier(add_func: MapElement) -> Optional[Union[ProcessFailureReason, MapElement]]:
        """
                   x + (-y)  =>  x - y
                (-x) + (-y)  =>  - (x + y)
        """
        assert isinstance(add_func, MultiAdd)
        if AssociativeListFunction.is_binary(add_func) or len(add_func.operands) != 2:
            return ProcessFailureReason("Not applicable", trivial = True)

        sign0, map0 = as_neg(add_func.operands[0])
        sign1, map1 = as_neg(add_func.operands[1])
        if sign0 != sign1:
            return Sub(map0, map1) if sign0 == 1 else Sub(map1, map0)

        if sign0 == sign1 == -1 and id(add_func) not in AssociativeListFunction.binary_constructs:
            return -Add(map0, map1)
        return ProcessFailureReason("Simplified in the binary addition version", trivial = True)

Add = MultiAdd([Var(f"X_Add_1"), Var(f"X_Add_2")])
MapElement.addition = Add

MultiAdd.register_class_simplifier(_sorted_commutative_simplifier)


# </editor-fold>


# <editor-fold desc=" ------------------- Subtraction ------------------- ">

class _Sub(CompositeElementFromFunction):

    def __init__(self, operands: Optional[List[MapElement]] = None):
        assert operands is None or len(operands) == 2
        super().__init__(operands=operands, name="Sub", function=lambda a, b: a - b)

    def _simplify_with_var_values2(self) -> Optional[MapElement]:
        operands = self.operands

        if operands[0].evaluate() == 0:
            return Neg(operands[1]).simplify2()
        if operands[1].evaluate() == 0:
            return operands[0]
        if operands[0] is operands[1]:
            # TODO:
            #   I do not use entries[0] == entries[1], because some places might use the definition for x == y
            #   as  x - y == 0. Consider adding 'equality' function that forbids this definition
            return MapElementConstant.zero

        sign0, map0 = as_neg(operands[0])
        sign1, map1 = as_neg(operands[1])

        if sign0 == -1 and sign1 == -1:
            return Sub(map1, map0).simplify2()
        if sign0 == 1 and sign1 == -1:
            return Add(map0, map1).simplify2()
        if sign0 == -1 and sign1 == 1:
            return (-Add(map1, map0)).simplify2()

        # sign0 == sign1 == 1
        return super()._simplify_with_var_values2()

    def to_string(self, vars_to_str: Dict[Var, str]):
        return f"({self.operands[0]}-{self.operands[1]})"

    @class_simplifier
    @staticmethod
    def _to_sub_simplifier(sub_func: MapElement) -> Optional[MapElement]:
        assert isinstance(sub_func, _Sub)
        return (sub_func.operands[0].sub(sub_func.operands[1]) or
                sub_func.operands[1].rsub(sub_func.operands[0]))

Sub = _Sub()
MapElement.subtraction = Sub

# </editor-fold>


# <editor-fold desc=" ------------------- Multiplication ------------------- ">


class _Mult(CompositeElementFromFunction):

    def __init__(self, operands: Optional[List[MapElement]] = None) -> None:
        assert operands is None or len(operands) == 2
        super().__init__(operands=operands, name="Mult", function=lambda a, b: a * b)

    def _simplify_with_var_values2(self) -> Optional[MapElement]:
        operands = self.operands

        # Multiplication by 0 and 1
        if operands[0].evaluate() == 0:
            return MapElementConstant.zero
        if operands[0].evaluate() == 1:
            return operands[1]

        if operands[1].evaluate() == 0:
            return MapElementConstant.zero
        if operands[1].evaluate() == 1:
            return operands[0]

        if operands[0].evaluate() == -1:
            return Neg(operands[1])
        if operands[1].evaluate() == -1:
            return Neg(operands[0])

        sign0, numerator0, denominator0 = _as_rational(operands[0])
        sign1, numerator1, denominator1 = _as_rational(operands[1])
        if operands[0] is numerator0 and operands[1] is numerator1:
            return super()._simplify_with_var_values2()

        numerator = numerator0 * numerator1
        denominator = denominator0 * denominator1
        abs_value = numerator / denominator
        return abs_value.simplify2() if sign0 * sign1 == 1 else (-abs_value).simplify2()

    def to_string(self, vars_to_str: Dict[Var, str]):
        return f"({self.operands[0]}*{self.operands[1]})"

    @class_simplifier
    @staticmethod
    def _to_mult_simplifier(mul_func: MapElement) -> Optional[MapElement]:
        assert isinstance(mul_func, _Mult)
        return (mul_func.operands[0].mul(mul_func.operands[1]) or
                mul_func.operands[1].mul(mul_func.operands[0]))

Mult = _Mult()
MapElement.multiplication = Mult

# </editor-fold>


# <editor-fold desc=" ------------------- Division ------------------- ">


class _Div(CompositeElementFromFunction):

    def __init__(self, operands: Optional[List[MapElement]] = None) -> None:
        assert operands is None or len(operands) == 2
        super().__init__(operands=operands, name="Div", function=lambda a, b: a / b)

    def _simplify_with_var_values2(self) -> Optional[MapElement]:
        operands = self.operands

        if operands[1] == 0:
            raise Exception("Cannot divide by zero")
        if operands[1] == 1:
            return operands[0]

        if operands[0] == 0:
            return operands[0]

        sign0, numerator0, denominator0 = _as_rational(operands[0])
        sign1, numerator1, denominator1 = _as_rational(operands[1])
        if operands[0] is numerator0 and operands[1] is numerator1:
            return super()._simplify_with_var_values2()

        abs_value = (numerator0 * denominator1) / (denominator0 * numerator1)
        return abs_value if sign0 * sign1 == 1 else -abs_value

    def to_string(self, vars_to_str: Dict[Var, str]):
        return f"( {self.operands[0]}/{self.operands[1]} )"

    @class_simplifier
    @staticmethod
    def _to_div_simplifier(div_func: MapElement) -> Optional[MapElement]:
        assert isinstance(div_func, _Div)
        return (div_func.operands[0].div(div_func.operands[1]) or
                div_func.operands[1].rdiv(div_func.operands[0]))

Div = _Div()
MapElement.division = Div

# </editor-fold>


# Arithmetic decompositions

def as_neg(map_elem: MapElement) -> Tuple[int, MapElement]:
    if isinstance(map_elem, _Negative):
        return -1, map_elem.operand

    return 1, map_elem

def _as_scalar_mult(map_elem: MapElement) -> Tuple[int, MapElement]:
    value = map_elem.evaluate()
    if value is not None:
        return value, MapElementConstant.one

    if not isinstance(map_elem, _Mult):
        return 1, map_elem

    a, b = map_elem.operands
    a_value = a.evaluate()
    b_value = b.evaluate()
    if a_value is not None:
        if b_value is not None:
            return a_value * b_value, MapElementConstant.one
        return a_value, b
    if b_value is not None:
        return b_value, a

    return 1, map_elem


# TODO: consider creating a LinearCombination class?
#       also, make this function recursive.
def _as_combination(map_elem: MapElement) -> Tuple[int, MapElement, int, MapElement]:
    if isinstance(map_elem, MapElementConstant):
        return map_elem.evaluate(), MapElementConstant.one, 0, MapElementConstant.zero

    if isinstance(map_elem, _Negative):
        c0, elem0, c1, elem1 = _as_combination(map_elem.operand)
        return -c0, elem0, -c1, elem1

    if isinstance(map_elem, MultiAdd):
        num_operands = len(map_elem.operands)
        if num_operands == 0:
            return 0, MapElementConstant.one, 0, MapElementConstant.zero
        if num_operands == 1:
            return _as_combination(map_elem.operands[0])
        if num_operands == 2:
            c0, elem0 = _as_scalar_mult(map_elem.operands[0])
            c1, elem1 = _as_scalar_mult(map_elem.operands[1])
            if c0 == 0 or elem0 is MapElementConstant.one:
                return c1, elem1, c0, elem0
            return c0, elem0, c1, elem1

    if isinstance(map_elem, _Add):
        c0, elem0 = _as_scalar_mult(map_elem.operands[0])
        c1, elem1 = _as_scalar_mult(map_elem.operands[1])
        if c0 == 0 or elem0 is MapElementConstant.one:
            return c1, elem1, c0, elem0
        return c0, elem0, c1, elem1

    if isinstance(map_elem, _Sub):
        c0, elem0 = _as_scalar_mult(map_elem.operands[0])
        c1, elem1 = _as_scalar_mult(map_elem.operands[1])
        if c0 == 0 or elem0 is MapElementConstant.one:
            return -c1, elem1, c0, elem0
        return c0, elem0, -c1, elem1

    c, elem = _as_scalar_mult(map_elem)
    return c, elem, 0, MapElementConstant.zero


def _as_rational(map_elem: MapElement) -> (int, MapElement, MapElement):
    """
    :return: sign, numerator, denominator
    """
    sign = 1
    if isinstance(map_elem, _Negative):
        sign = -1
        map_elem = map_elem.operand

    if isinstance(map_elem, _Div):
        return sign, map_elem.operands[0], map_elem.operands[1]

    return sign, map_elem, MapElementConstant.one


class BinaryCombination(MapElement):
    # TODO: Right now this is ONLY used for the simplification process inside Linear. Don't generate it for other
    #       reasons.
    #       Later, I should just make a LinearCombination element for expressions of the form sum c_i f_i

    def __init__(self, c1: int, elem1: MapElement, c2: int, elem2: MapElement):
        super().__init__(list(set(elem1.vars + elem2.vars)))
        self.c1 = c1
        self.elem1 = elem1
        self.c2 = c2
        self.elem2 = elem2

    def to_string(self, vars_to_str: Dict[Var, str]):
        return f"Comb[{self.c1}*{self.elem1.to_string(vars_to_str)}+{self.c2}*{self.elem2.to_string(vars_to_str)}]"

    def _simplify_with_var_values2(self) -> Optional[MapElement]:
        if self.c1 == 0:
            return self.c2 * self.elem2
        if self.c2 == 0:
            return self.c1 * self.elem1

        elem1 = self.elem1._simplify2()
        elem2 = self.elem2._simplify2()
        if elem1 is not None or elem2 is not None:
            elem1 = elem1 or self.elem1
            elem2 = elem2 or self.elem2
            return BinaryCombination(self.c1, elem1, self.c2, elem2)
        return None


# TODO: add tests
def _binary_combination_simplifier(function: MapElement) -> Optional[Union[MapElement, ProcessFailureReason]]:
    assert isinstance(function, (_Add, _Sub))
    c1, elem1, c2, elem2 = _as_combination(function)
    if c2 == 0:
        return None
    result = BinaryCombination(c1, elem1, c2, elem2)._simplify2()
    if result is None or isinstance(result, BinaryCombination):
        return None
    return result


# TODO: should class simplifiers be inherited?
_Add.register_class_simplifier(_binary_combination_simplifier)
_Sub.register_class_simplifier(_binary_combination_simplifier)

def _binary_commutative_simplifier(function: MapElement) -> Optional[Union[MapElement, ProcessFailureReason]]:
    assert isinstance(function, (_Add, _Mult))
    operands = function.operands
    # Comparison:
    #   1. First by number of variables
    #   2. If have the same number of variables, compare by their names (sorted)
    #   3. If have the exact same variables, just compare by the string representation of the functions.
    key1 = (operands[0].num_vars, sorted([v.name for v in operands[0].vars]), str(operands[0]))
    key2 = (operands[1].num_vars, sorted([v.name for v in operands[1].vars]), str(operands[1]))
    if key1 > key2:
        return function.copy_with_operands(operands=[operands[1], operands[0]])
    return ProcessFailureReason("Did not need to change the order of parts", trivial=True)
_Add.register_class_simplifier(_binary_commutative_simplifier)
_Mult.register_class_simplifier(_binary_commutative_simplifier)
